<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Farm Planner â€” Demo</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --panel-2:#0f1730; --text:#eaf0ff;
      --muted:#9fb2e1; --accent:#6aa3ff; --border: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; margin:0; background:var(--bg); color:var(--text); }
    header { padding:14px 16px; background:linear-gradient(180deg, #121a33, #0f1730); border-bottom:1px solid var(--border); }
    h1 { font-size:18px; margin:0; letter-spacing:.3px; }
    h2 { font-size:15px; margin: 6px 0 10px; color: var(--muted); font-weight:600; }
    h3 { font-size:13px; margin: 12px 0 6px; color: var(--muted); font-weight:600; }
    .wrap { display:grid; grid-template-columns: 420px 1fr; gap:14px; padding:14px; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px; box-shadow: 0 1px 0 rgba(0,0,0,0.2), 0 8px 24px rgba(0,0,0,0.25); }
    #map { height:520px; border-radius:10px; overflow:hidden; border:1px solid var(--border); }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 6px; }
    label { font-size:12px; display:block; margin-top:8px; color: var(--muted); }
    input { width:100%; padding:10px 12px; margin-top:6px; border-radius:10px; border:1px solid var(--border); background:var(--panel-2); color:var(--text); outline:none; transition: border-color .15s ease, box-shadow .15s ease; }
    input:focus { border-color: rgba(106,163,255,.6); box-shadow: 0 0 0 3px rgba(106,163,255,.15); }
    button { padding:10px 12px; border-radius:10px; border:1px solid var(--border); background: linear-gradient(180deg, #1a244a, #142244); color: var(--text); cursor:pointer; font-weight:600; letter-spacing:.2px; transition: transform .05s ease, filter .15s ease, border-color .15s ease; }
    button:hover { filter: brightness(1.08); border-color: rgba(106,163,255,.5); }
    button:active { transform: translateY(1px); }
    pre { background:var(--panel-2); padding:12px; border-radius:10px; border:1px solid var(--border); overflow:auto; line-height:1.45; font-size:12.5px; }
    pre.empty { color: #7f8fb7; font-style: italic; }
    /* JSON syntax highlighting */
    .json-view .key { color:#8ab4ff; }
    .json-view .string { color:#b5f4a5; }
    .json-view .number { color:#ffd399; }
    .json-view .boolean { color:#ffb5c3; }
    .json-view .null { color:#a0a8b8; font-style: italic; }
    @media(max-width:1100px){.wrap{grid-template-columns:1fr;}#map{height:360px}}
  </style>
</head>
<body>
  <header><h1>Farm Planner Demo</h1></header>
  <div class="wrap">
    <div class="card">
      <h2>Parcel Search</h2>
      <label>Address</label>
      <input id="addr" value="9898 Seahawk Rd, Berlin, MD 21811" />
      <div class="row">
        <button id="btnSearch">Search Parcel</button>
        <button id="btnQuick">Run Quick Analysis</button>
        <button id="btnPlace">Show Houses</button>
      </div>
      <pre id="parcelJson" class="json-view empty">No response yet.</pre>
      <h3>Quick Analysis Result</h3>
      <h2>Economics</h2>
      <label>Workers</label><input id="workers" type="number" value="6" />
      <label>Weekly pay/worker</label><input id="pay" type="number" value="750" />
      <label>Land price</label><input id="price" type="number" value="400000" />
      <label>Down payment %</label><input id="dpct" type="number" step="0.01" />
      <label>Down payment $</label><input id="damt" type="number" step="0.01" />
      <label>Interest rate %</label><input id="rate" type="number" step="0.01" value="6.5" />
      <label>Years</label><input id="years" type="number" value="20" />
      <button id="btnEcon">Compute</button>
      <pre id="econJson" class="json-view empty">No response yet.</pre>
    </div>
    <div class="card">
      <h2>Map</h2>
      <div id="map"></div>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // Presentation helpers for JSON output
    function escapeHtml(str){
      return str.replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
    function highlightJSON(jsonString){
      const esc = escapeHtml(jsonString);
      return esc
        .replace(/(^|\n)(\s*)\"([^\"]+)\"(\s*):/g, (m, a, b, key, c) => `${a}${b}<span class="key">"${key}"</span>${c}:`)
        .replace(/:\s*\"([^\"]*)\"/g, (m) => m.replace(/\"([^\"]*)\"/, (mm, v) => `"<span class=\"string\">${v}</span>"`))
        .replace(/\b(true|false)\b/g, '<span class="boolean">$1</span>')
        .replace(/\bnull\b/g, '<span class="null">null</span>')
        .replace(/(?<=[:\s\[])(-?\d+(?:\.\d+)?)(?=\s*[,\]\n])/g, '<span class="number">$1</span>');
    }
    function renderJSONPre(el, rawText){
      el.classList.remove('empty');
      try{
        const obj = JSON.parse(rawText);
        const pretty = JSON.stringify(obj, null, 2);
        el.innerHTML = highlightJSON(pretty);
      }catch{
        el.textContent = rawText;
      }
    }
    function setLoading(el, text){ el.classList.remove('empty'); el.textContent = text; }
    const API_BASE = (location.protocol === 'file:') ? 'http://localhost:8080' : '';
    const map = L.map('map').setView([38.18,-75.39], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    let parcelLayer;
    let lastQuickFit = null; // store last quick analysis result for econ assess
    let housesLayer;         // layer group for placed houses
    let lastParcelPoly = null; // { outer: [{lat,lon}], holes: [[{lat,lon}], ...] }

    function renderGeoJSON(geo){
      if (parcelLayer) map.removeLayer(parcelLayer);
      parcelLayer = L.geoJSON(geo).addTo(map);
      try { map.fitBounds(parcelLayer.getBounds()); } catch{}

      // Extract primary polygon (largest area) with holes for placement and clear houses
      lastParcelPoly = extractPrimaryPolygon(parcelLayer);
      if (housesLayer) { map.removeLayer(housesLayer); housesLayer = null; }
    }

    // Extract the largest polygon from the layer with its holes
    function extractPrimaryPolygon(layer){
      let best = null; // { outer, holes, area }
      layer.eachLayer(l => {
        if (!(l instanceof L.Polygon)) return;
        const ll = l.getLatLngs();
        // Normalize: MultiPolygon -> [ [rings], ... ]; Polygon -> [rings]
        const polys = (Array.isArray(ll[0]) && Array.isArray(ll[0][0])) ? ll : [ll];
        for (const poly of polys){
          if (!Array.isArray(poly) || poly.length === 0) continue;
          const outerLL = poly[0];
          const holesLL = poly.slice(1);
          const outer = outerLL.map(pt => ({lat: pt.lat, lon: pt.lng}));
          const holes = holesLL.map(r => r.map(pt => ({lat: pt.lat, lon: pt.lng})));
          const area = Math.abs(polygonArea(outer));
          if (!best || area > best.area) best = { outer, holes, area };
        }
      });
      return best ? { outer: best.outer, holes: best.holes } : null;
    }

    // Signed area via shoelace (in degrees^2)
    function polygonArea(ring){
      let a = 0; const n = ring.length;
      for (let i=0, j=n-1; i<n; j=i++) a += (ring[j].lon * ring[i].lat) - (ring[i].lon * ring[j].lat);
      return 0.5 * a;
    }

    function feetPerDegree(lat){
      const ftPerDegLat = 364000; // approx
      const ftPerDegLon = 364000 * Math.cos(lat * Math.PI/180);
      return {ftPerDegLat, ftPerDegLon};
    }

    // Simple point-in-polygon (ray casting); polygon: array of {lat,lon}
    function isPointInPolygon(pt, polygon){
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].lon, yi = polygon[i].lat;
        const xj = polygon[j].lon, yj = polygon[j].lat;
        const intersect = ((yi > pt.lat) !== (yj > pt.lat)) &&
          (pt.lon < (xj - xi) * (pt.lat - yi) / ((yj - yi) || 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Outer must contain; none of the holes may contain
    function isInsideParcel(pt){
      if (!lastParcelPoly) return false;
      if (!isPointInPolygon(pt, lastParcelPoly.outer)) return false;
      for (const hole of (lastParcelPoly.holes || [])){
        if (isPointInPolygon(pt, hole)) return false;
      }
      return true;
    }

    async function fetchRules(){
      try{
        const res = await fetch(`${API_BASE}/api/rules`);
        if (!res.ok) return null;
        return await res.json();
      }catch{ return null; }
    }

    async function placeHouses(){
      if (!lastQuickFit || !lastQuickFit.found) { alert('Run Quick Analysis first'); return; }
      if (!lastParcelPoly) { alert('No parcel geometry to place houses.'); return; }
      const polygon = lastParcelPoly.outer;
      const houses = Math.max(0, +lastQuickFit.maxHouses || 0);
      if (houses === 0) { alert('No houses fit on this parcel.'); return; }

      const rules = await fetchRules();
      const widthFt = (rules && rules.houseWidthFt) ? +rules.houseWidthFt : 66;
      const lengthFt = (rules && rules.houseLengthFt) ? +rules.houseLengthFt : 650;
      const aisleFt = 50; // spacing between houses

      // Choose an orientation: try longest edge bearing, 90 deg, and fallbacks 0/90
      const {thetaGuess, bbox} = estimateOrientationAndBBox(polygon);
      const angles = uniqueAngles([thetaGuess, thetaGuess + Math.PI/2, 0, Math.PI/2]);

      const results = angles.map(a => ({ angle:a, centers: planPlacement(polygon, a, widthFt, lengthFt, aisleFt, houses, bbox, true) }));
      results.sort((p,q)=> q.centers.length - p.centers.length);
      const best = results[0];
      const centers = planPlacement(polygon, best.angle, widthFt, lengthFt, aisleFt, houses, bbox, false);

      if (housesLayer) { map.removeLayer(housesLayer); }
      housesLayer = L.layerGroup().addTo(map);
      drawRectangles(centers, best.angle, widthFt, lengthFt);

      if (centers.length < houses) {
        console.warn(`Placed ${centers.length}/${houses} houses for angle ${(best.angle*180/Math.PI).toFixed(1)}Â°.`);
      }
    }

    function uniqueAngles(arr){
      const norm = a => ((a % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
      const out=[]; for (const a of arr){ const na=norm(a); if(!out.some(b=>Math.abs(norm(b)-na)<1e-6)) out.push(na);} return out;
    }

    function estimateOrientationAndBBox(polygon){
      let minLat=+Infinity,maxLat=-Infinity,minLon=+Infinity,maxLon=-Infinity;
      for (const p of polygon){
        if (p.lat < minLat) minLat = p.lat;
        if (p.lat > maxLat) maxLat = p.lat;
        if (p.lon < minLon) minLon = p.lon;
        if (p.lon > maxLon) maxLon = p.lon;
      }
      const lat0 = (minLat + maxLat)/2;
      const {ftPerDegLat, ftPerDegLon} = feetPerDegree(lat0);
      // Find longest edge bearing using local feet metric
      let bestLen=0, theta=0;
      for (let i=0;i<polygon.length-1;i++){
        const a=polygon[i], b=polygon[i+1];
        const eFeet=(b.lon-a.lon)*ftPerDegLon; // east component feet
        const nFeet=(b.lat-a.lat)*ftPerDegLat; // north component feet
        const len=Math.hypot(eFeet,nFeet);
        if(len>bestLen){ bestLen=len; theta=Math.atan2(nFeet,eFeet); }
      }
      return { thetaGuess: theta, bbox: {minLat,maxLat,minLon,maxLon,lat0,ftPerDegLat,ftPerDegLon} };
    }

    function planPlacement(polygon, theta, widthFt, lengthFt, aisleFt, houses, bbox, simulate){
      const {minLat,maxLat,minLon,maxLon,lat0,ftPerDegLat,ftPerDegLon} = bbox;
      // Axis unit vectors in EN feet: len axis (cos,sin), wid axis (-sin,cos)
      const c=Math.cos(theta), s=Math.sin(theta);
      const stepLenFt = lengthFt + aisleFt;
      const stepWidFt = widthFt + aisleFt;
      const halfLen = lengthFt/2, halfWid = widthFt/2;
      // Convert to degree step vectors
      const dLen = { dlon: (stepLenFt*c)/ftPerDegLon, dlat: (stepLenFt*s)/ftPerDegLat };
      const dWid = { dlon: (-stepWidFt*s)/ftPerDegLon, dlat: (stepWidFt*c)/ftPerDegLat };
      const halfLenVec = { dlon: (halfLen*c)/ftPerDegLon, dlat: (halfLen*s)/ftPerDegLat };
      const halfWidVec = { dlon: (-halfWid*s)/ftPerDegLon, dlat: (halfWid*c)/ftPerDegLat };

      // Search grid size estimate (in feet, project AABB onto axes)
      const widthFeet = (maxLon-minLon)*ftPerDegLon;
      const heightFeet = (maxLat-minLat)*ftPerDegLat;
      const spanLenFt = Math.abs(c)*widthFeet + Math.abs(s)*heightFeet;
      const spanWidFt = Math.abs(s)*widthFeet + Math.abs(c)*heightFeet;
      const nI = Math.min(200, Math.max(1, Math.ceil(spanLenFt/stepLenFt) + 2));
      const nJ = Math.min(200, Math.max(1, Math.ceil(spanWidFt/stepWidFt) + 2));

      // Start near bottom-left of AABB with a small margin
      const marginFt = 25;
      const origin = { lat: minLat + (marginFt/ftPerDegLat), lon: minLon + (marginFt/ftPerDegLon) };

      const centers=[];
      // Try two phase offsets to reduce alignment artifacts
      const phases = [ {oi:0, oj:0}, {oi:0.5, oj:0.5} ];
      for (const ph of phases){
        for (let i=0; i<nI && centers.length < houses; i++){
          for (let j=0; j<nJ && centers.length < houses; j++){
            const lat = origin.lat + (i+ph.oi)*dLen.dlat + (j+ph.oj)*dWid.dlat;
            const lon = origin.lon + (i+ph.oi)*dLen.dlon + (j+ph.oj)*dWid.dlon;
            // Quick reject by AABB with padding
            if (lat < minLat-1e-6 || lat > maxLat+1e-6 || lon < minLon-1e-6 || lon > maxLon+1e-6) continue;
            const center = {lat, lon};
            const corners = [
              {lat: lat - halfLenVec.dlat - halfWidVec.dlat, lon: lon - halfLenVec.dlon - halfWidVec.dlon},
              {lat: lat - halfLenVec.dlat + halfWidVec.dlat, lon: lon - halfLenVec.dlon + halfWidVec.dlon},
              {lat: lat + halfLenVec.dlat + halfWidVec.dlat, lon: lon + halfLenVec.dlon + halfWidVec.dlon},
              {lat: lat + halfLenVec.dlat - halfWidVec.dlat, lon: lon + halfLenVec.dlon - halfWidVec.dlon}
            ];
            if (!isInsideParcel(center) || corners.some(c => !isInsideParcel(c))) continue;
            centers.push(center);
          }
        }
        if (centers.length >= houses) break;
      }
      return simulate ? centers.slice(0) : centers;
    }

    function drawRectangles(centers, theta, widthFt, lengthFt){
      // Compute degree offsets for half-dim vectors once per center lat
      for (const c of centers){
        const {ftPerDegLat, ftPerDegLon} = feetPerDegree(c.lat);
        const halfLen = lengthFt/2, halfWid = widthFt/2;
        const ct=Math.cos(theta), st=Math.sin(theta);
        const halfLenVec = { dlon: (halfLen*ct)/ftPerDegLon, dlat: (halfLen*st)/ftPerDegLat };
        const halfWidVec = { dlon: (-halfWid*st)/ftPerDegLon, dlat: (halfWid*ct)/ftPerDegLat };
        const rect = [
          [c.lat - halfLenVec.dlat - halfWidVec.dlat, c.lon - halfLenVec.dlon - halfWidVec.dlon],
          [c.lat - halfLenVec.dlat + halfWidVec.dlat, c.lon - halfLenVec.dlon + halfWidVec.dlon],
          [c.lat + halfLenVec.dlat + halfWidVec.dlat, c.lon + halfLenVec.dlon + halfWidVec.dlon],
          [c.lat + halfLenVec.dlat - halfWidVec.dlat, c.lon + halfLenVec.dlon - halfWidVec.dlon],
          [c.lat - halfLenVec.dlat - halfWidVec.dlat, c.lon - halfLenVec.dlon - halfWidVec.dlon]
        ];
        L.polygon(rect, {color:'#ffcc00', weight:1, fillColor:'#ffcc00', fillOpacity:0.35}).addTo(housesLayer);
      }
    }

    function xsrfHeaders(){
      const m=document.cookie.match(/XSRF-TOKEN=([^;]+)/);
      return m?{'X-XSRF-TOKEN':decodeURIComponent(m[1])}:{};
    }

    document.getElementById('btnSearch').onclick = async () => {
      const addr=document.getElementById('addr').value;
      const out=document.getElementById('parcelJson');
      setLoading(out, 'Loadingâ€¦');
      try{
        const controller = new AbortController();
        const t = setTimeout(()=>controller.abort(), 12000);
        const res=await fetch(`${API_BASE}/api/parcels/search`,{
          method:'POST',headers:{'Content-Type':'application/json',...xsrfHeaders()},
          credentials:'include',signal:controller.signal,body:JSON.stringify({address:addr})});
        clearTimeout(t);
        const txt=await res.text();
        const body = res.ok ? txt : `HTTP ${res.status} ${res.statusText}\n\n`+txt;
        renderJSONPre(out, body);
        try{const d=JSON.parse(txt);const geo=d.geometry||d.data?.geometry||(d.type==='FeatureCollection'?d:null);if(geo)renderGeoJSON(geo);}catch{}
      }catch(e){ out.textContent='Network error: '+(e.name==='AbortError'?'timeout':'')+' '+e; }
    };

    document.getElementById('btnQuick').onclick = async () => {
      const addr=document.getElementById('addr').value;
      const out=document.getElementById('parcelJson');
      setLoading(out, 'Loading quick analysisâ€¦');
      try{
        const res=await fetch(`${API_BASE}/api/analysis/quick`,{
          method:'POST',headers:{'Content-Type':'application/json'},
          credentials:'include',body:JSON.stringify({address:addr})});
        const txt=await res.text();
        const body = res.ok ? txt : `HTTP ${res.status} ${res.statusText}\n\n`+txt;
        renderJSONPre(out, body);
        // Try to capture the quick fit result for later econ assessment
        try {
          const data = JSON.parse(txt);
          lastQuickFit = data;
        } catch(e) {
          lastQuickFit = null;
        }
      }catch(e){ out.textContent='Error '+e; }
    };

    document.getElementById('btnPlace').onclick = async () => {
      try { await placeHouses(); } catch(e) { console.error(e); alert('Failed to place houses: '+e); }
    };

    document.getElementById('btnEcon').onclick = async () => {
      // Validate we have a quick analysis result first
      if (!lastQuickFit) {
        document.getElementById('econJson').textContent = 'Please run Quick Analysis first.';
        return;
      }
      // Convert down payment % input from percent to fraction if provided
      const dpctVal = dpct.value ? (+dpct.value / 100) : null;
      const payload={
        fit: lastQuickFit,
        workers:+workers.value,
        weeklyPayPerWorker:+pay.value,
        landPrice:+price.value,
        downPaymentPct: dpctVal,
        downPaymentAmount: damt.value?+damt.value:null,
        annualInterestRatePct:+rate.value,
        years:+years.value
      };
      const out=document.getElementById('econJson');
      setLoading(out, 'Loadingâ€¦');
      try{
        const res=await fetch(`${API_BASE}/api/analysis/econ/assess`,{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          credentials:'include',
          body:JSON.stringify(payload)
        });
        const txt = await res.text();
        const body = res.ok ? txt : `HTTP ${res.status} ${res.statusText}\n\n`+txt;
        renderJSONPre(out, body);
      }catch(e){out.textContent='Error '+e;}
    };
  </script>
</body>
</html>
